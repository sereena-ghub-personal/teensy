#include <Servo.h>

/* ---------------------------------------------------------
   SERVO OBJECTS & PIN ASSIGNMENTS
--------------------------------------------------------- */
Servo servoRight;
Servo servoLeft;

const byte pinServoRight    = 6;
const byte pinServoLeft     = 5;
const byte pinFeedbackRight = 8;
const byte pinFeedbackLeft  = 7;

/* ---------------------------------------------------------
   SERVO CALIBRATION
   (Tune these values if robot drifts)
--------------------------------------------------------- */
const int STOP_PULSE = 94;
const int FWD_RIGHT = 92;
const int FWD_LEFT  = 96;
const int BWD_RIGHT = 96;
const int BWD_LEFT  = 92;

/* ---------------------------------------------------------
   ROBOT PARAMETERS
--------------------------------------------------------- */
const float wheelDiameter = 0.03;                 // meters
const float wheelCirc = 3.14159 * wheelDiameter;  // ≈ 0.0942 m
const float targetDist = 2.0;                     // forward/backward distance
const float targetRotations = targetDist / wheelCirc;

/* ---------------------------------------------------------
   ENCODER VARIABLES
--------------------------------------------------------- */
volatile float thetaRight = 0, thetaLeft = 0;
volatile float prevThetaRight = 0, prevThetaLeft = 0;

volatile long turnsRight = 0, turnsLeft = 0;

float totalRotRight = 0, totalRotLeft = 0;

/* ---------------------------------------------------------
   CONTROL GAINS
--------------------------------------------------------- */
float Kp = 3.0;         // proportional gain
int P_right = 0, P_left = 0;

/* ---------------------------------------------------------
   DEBUG OPTION
--------------------------------------------------------- */
bool DEBUG = false;

/* ---------------------------------------------------------
   READ PARALLAX 360° ENCODER ANGLE
--------------------------------------------------------- */
float readTheta(byte pin) {
  unsigned long highTime = pulseIn(pin, HIGH, 20000);  // 20ms timeout
  unsigned long lowTime  = pulseIn(pin, LOW, 20000);

  if (highTime == 0 || lowTime == 0) return 0;  // no signal

  float duty = (highTime * 100.0) / (highTime + lowTime);

  float angle = (duty - 2.9) * (360.0 / (97.1 - 2.9));
  if (angle < 0) angle = 0;
  if (angle > 360) angle = 360;

  return angle;
}

/* ---------------------------------------------------------
   UPDATE ROTATION COUNT
--------------------------------------------------------- */
void updateRotation() {
  thetaRight = readTheta(pinFeedbackRight);
  thetaLeft  = readTheta(pinFeedbackLeft);

  if (thetaRight == 0) {
  Serial.println("RIGHT ENCODER LOST – STOPPING");
  totalRotRight = targetRotations + 1;  // force loop exit
  return;
  }

  float dR = thetaRight - prevThetaRight;
  float dL = thetaLeft - prevThetaLeft;

  // Wrap detection
  if (dR > 180)  { turnsRight--; dR -= 360; }
  if (dR < -180) { turnsRight++; dR += 360; }

  if (dL > 180)  { turnsLeft--; dL -= 360; }
  if (dL < -180) { turnsLeft++; dL += 360; }

  totalRotRight = turnsRight + thetaRight / 360.0;
  totalRotLeft  = turnsLeft  + thetaLeft  / 360.0;

  prevThetaRight = thetaRight;
  prevThetaLeft  = thetaLeft;

  if (DEBUG) {
    Serial.print("R: ");
    Serial.print(totalRotRight, 3);
    Serial.print(" L: ");
    Serial.println(totalRotLeft, 3);
  }

   if (thetaRight == 0) {
     Serial.println("WARNING: Right encoder signal LOST");
   }
}

/* ---------------------------------------------------------
   PROPORTIONAL CONTROL (SIGNED FORWARD/BACKWARD)
--------------------------------------------------------- */
void updatePcontrol(bool forward) {
  float error;

  if (forward) 
      error = totalRotLeft - totalRotRight;
  else  
      error = totalRotRight - totalRotLeft;  // reverse sign for backward

  int correction = Kp * error;

  P_right = correction;
  P_left  = -correction;
}

/* ---------------------------------------------------------
   DRIVE FORWARD USING FEEDBACK CONTROL
--------------------------------------------------------- */
void driveForwardControlled() {
  servoRight.attach(pinServoRight);
  servoLeft.attach(pinServoLeft);

  Serial.println("Driving FORWARD...");

  while (totalRotRight < targetRotations &&
         totalRotLeft  < targetRotations) 
  {
    updateRotation();
    updatePcontrol(true);

    servoRight.write(FWD_RIGHT + P_right);
    servoLeft.write(FWD_LEFT + P_left);
  }

  servoRight.detach();
  servoLeft.detach();

  Serial.println("FORWARD complete");
}

/* ---------------------------------------------------------
   DRIVE BACKWARD USING FEEDBACK CONTROL
--------------------------------------------------------- */
void driveBackwardControlled() {
  servoRight.attach(pinServoRight);
  servoLeft.attach(pinServoLeft);

  Serial.println("Driving BACKWARD...");

  while (totalRotRight < targetRotations &&
         totalRotLeft  < targetRotations) 
  {
    updateRotation();
    updatePcontrol(false);

    servoRight.write(BWD_RIGHT + P_right);
    servoLeft.write(BWD_LEFT + P_left);
  }

  servoRight.detach();
  servoLeft.detach();

  Serial.println("BACKWARD complete");
}

/* ---------------------------------------------------------
   RESET ENCODER STATE
--------------------------------------------------------- */
void resetEncoders() {
  turnsRight = turnsLeft = 0;
  totalRotRight = totalRotLeft = 0;

  // IMPORTANT: read actual starting angle
  prevThetaRight = readTheta(pinFeedbackRight);
  prevThetaLeft  = readTheta(pinFeedbackLeft);
}


/* ---------------------------------------------------------
   SETUP
--------------------------------------------------------- */
void setup() {
  Serial.begin(9600);

  pinMode(pinFeedbackRight, INPUT);
  pinMode(pinFeedbackLeft, INPUT);

  delay(2000);
  Serial.println("Robot ready. Send 'f' to start full sequence.");
}

/* ---------------------------------------------------------
   LOOP
--------------------------------------------------------- */
void loop() {
  if (Serial.available() > 0) {
    char cmd = Serial.read();

    if (cmd == 'd') { DEBUG = !DEBUG; }

    if (cmd == 'f') {
      Serial.println("Command received: f");

      // Forward motion
      resetEncoders();
      driveForwardControlled();

      delay(700);

      // Backward motion
      Serial.println("Calling BACKWARD now!");
      resetEncoders();
      driveBackwardControlled();

      Serial.println("Sequence finished.");
    }
  }
}
