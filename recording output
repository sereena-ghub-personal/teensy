>>> Starting forward-backward cycle...

--- FORWARD 2m START ---
FWD | t = 0.01 s  | R: 0.000 turns, L: 0.001 turns  | avg dist ≈ 0.000 m  | error(turns) = 0.0006  | PWM R/L = 89/98
FWD | t = 0.41 s  | R: 0.145 turns, L: 0.189 turns  | avg dist ≈ 0.035 m  | error(turns) = 0.0443  | PWM R/L = 89/98
FWD | t = 0.81 s  | R: 0.365 turns, L: 0.425 turns  | avg dist ≈ 0.082 m  | error(turns) = 0.0603  | PWM R/L = 88/98
FWD | t = 1.22 s  | R: 1.552 turns, L: 0.687 turns  | avg dist ≈ 0.232 m  | error(turns) = -0.8651  | PWM R/L = 98/100
FWD | t = 1.63 s  | R: 1.669 turns, L: 1.044 turns  | avg dist ≈ 0.281 m  | error(turns) = -0.6250  | PWM R/L = 95/100
FWD | t = 2.03 s  | R: 1.696 turns, L: 1.404 turns  | avg dist ≈ 0.321 m  | error(turns) = -0.2924  | PWM R/L = 92/100
FWD | t = 2.43 s  | R: 1.778 turns, L: 1.746 turns  | avg dist ≈ 0.365 m  | error(turns) = -0.0320  | PWM R/L = 89/98
FWD | t = 2.83 s  | R: 1.975 turns, L: 1.994 turns  | avg dist ≈ 0.412 m  | error(turns) = 0.0193  | PWM R/L = 89/98
FWD | t = 3.24 s  | R: 2.179 turns, L: 2.241 turns  | avg dist ≈ 0.458 m  | error(turns) = 0.0627  | PWM R/L = 88/97
FWD | t = 3.64 s  | R: 2.424 turns, L: 2.483 turns  | avg dist ≈ 0.509 m  | error(turns) = 0.0590  | PWM R/L = 88/98
FWD | t = 4.05 s  | R: 2.686 turns, L: 3.603 turns  | avg dist ≈ 0.652 m  | error(turns) = 0.9179  | PWM R/L = 87/91
FWD | t = 4.45 s  | R: 2.988 turns, L: 3.625 turns  | avg dist ≈ 0.686 m  | error(turns) = 0.6365  | PWM R/L = 87/93
FWD | t = 4.86 s  | R: 3.285 turns, L: 3.643 turns  | avg dist ≈ 0.718 m  | error(turns) = 0.3582  | PWM R/L = 87/95
FWD | t = 5.26 s  | R: 3.579 turns, L: 3.762 turns  | avg dist ≈ 0.761 m  | error(turns) = 0.1829  | PWM R/L = 87/97
FWD | t = 5.66 s  | R: 3.855 turns, L: 3.954 turns  | avg dist ≈ 0.809 m  | error(turns) = 0.0990  | PWM R/L = 88/97
FWD | t = 6.07 s  | R: 4.094 turns, L: 4.157 turns  | avg dist ≈ 0.855 m  | error(turns) = 0.0632  | PWM R/L = 88/97
FWD | t = 6.47 s  | R: 4.339 turns, L: 4.400 turns  | avg dist ≈ 0.906 m  | error(turns) = 0.0611  | PWM R/L = 88/98
FWD | t = 6.87 s  | R: 4.577 turns, L: 4.651 turns  | avg dist ≈ 0.957 m  | error(turns) = 0.0742  | PWM R/L = 88/97
FWD | t = 7.28 s  | R: 4.828 turns, L: 4.881 turns  | avg dist ≈ 1.007 m  | error(turns) = 0.0524  | PWM R/L = 88/98
FWD | t = 7.68 s  | R: 5.072 turns, L: 5.135 turns  | avg dist ≈ 1.058 m  | error(turns) = 0.0632  | PWM R/L = 88/97
!! Timeout in moveForward2m, stopping.
--- FORWARD 2m END ---
Final turns  R: 5.264  L: 5.324  | avg distance ≈ 1.098 m

>>> Waiting 3 seconds before moving backward...
--- BACKWARD 2m START ---
BACK | t = 0.01 s  | R: 0.000 turns, L: 0.001 turns  | avg dist ≈ 0.000 m  | error(turns) = 0.0007  | PWM R/L = 99/90
BACK | t = 0.41 s  | R: 0.172 turns, L: 0.039 turns  | avg dist ≈ 0.022 m  | error(turns) = -0.1328  | PWM R/L = 100/91
BACK | t = 0.81 s  | R: 0.500 turns, L: 0.069 turns  | avg dist ≈ 0.059 m  | error(turns) = -0.4314  | PWM R/L = 102/93
BACK | t = 1.21 s  | R: 0.889 turns, L: 0.126 turns  | avg dist ≈ 0.105 m  | error(turns) = -0.7630  | PWM R/L = 102/96
BACK | t = 1.61 s  | R: 1.267 turns, L: 0.300 turns  | avg dist ≈ 0.162 m  | error(turns) = -0.9670  | PWM R/L = 102/98
BACK | t = 2.02 s  | R: 2.578 turns, L: 0.584 turns  | avg dist ≈ 0.328 m  | error(turns) = -1.9942  | PWM R/L = 102/100
BACK | t = 2.42 s  | R: 2.958 turns, L: 0.944 turns  | avg dist ≈ 0.405 m  | error(turns) = -2.0142  | PWM R/L = 102/100
BACK | t = 2.83 s  | R: 3.337 turns, L: 1.308 turns  | avg dist ≈ 0.482 m  | error(turns) = -2.0292  | PWM R/L = 102/100
BACK | t = 3.23 s  | R: 3.728 turns, L: 1.678 turns  | avg dist ≈ 0.560 m  | error(turns) = -2.0503  | PWM R/L = 102/100
BACK | t = 3.63 s  | R: 4.106 turns, L: 2.037 turns  | avg dist ≈ 0.637 m  | error(turns) = -2.0693  | PWM R/L = 102/100
BACK | t = 4.04 s  | R: 4.498 turns, L: 2.414 turns  | avg dist ≈ 0.717 m  | error(turns) = -2.0843  | PWM R/L = 102/100
BACK | t = 4.44 s  | R: 4.872 turns, L: 2.767 turns  | avg dist ≈ 0.792 m  | error(turns) = -2.1042  | PWM R/L = 102/100
BACK | t = 4.84 s  | R: 5.252 turns, L: 3.131 turns  | avg dist ≈ 0.869 m  | error(turns) = -2.1203  | PWM R/L = 102/100
BACK | t = 5.24 s  | R: 5.642 turns, L: 3.502 turns  | avg dist ≈ 0.948 m  | error(turns) = -2.1400  | PWM R/L = 102/100
BACK | t = 5.65 s  | R: 6.022 turns, L: 3.861 turns  | avg dist ≈ 1.025 m  | error(turns) = -2.1611  | PWM R/L = 102/100
BACK | t = 6.05 s  | R: 6.400 turns, L: 4.224 turns  | avg dist ≈ 1.101 m  | error(turns) = -2.1764  | PWM R/L = 102/100
BACK | t = 6.45 s  | R: 6.789 turns, L: 4.593 turns  | avg dist ≈ 1.180 m  | error(turns) = -2.1957  | PWM R/L = 102/100
BACK | t = 6.86 s  | R: 7.171 turns, L: 4.953 turns  | avg dist ≈ 1.257 m  | error(turns) = -2.2175  | PWM R/L = 102/100
BACK | t = 7.26 s  | R: 7.562 turns, L: 5.314 turns  | avg dist ≈ 1.335 m  | error(turns) = -2.2475  | PWM R/L = 102/100
BACK | t = 7.67 s  | R: 7.941 turns, L: 5.687 turns  | avg dist ≈ 1.413 m  | error(turns) = -2.2534  | PWM R/L = 102/100
!! Timeout in moveBackward2m, stopping.
-- BACKWARD 2m END ---
Final turns  R: 8.255  L: 5.987  | avg distance ≈ 1.477 m

>>> Cycle complete!



















new output
=======================


>>> Starting forward-backward cycle...

--- FORWARD 2m START ---
FWD | t = 0.01 s  | R: 0.000 turns, L: 0.000 turns  | avg dist ≈ 0.000 m  | error(turns) = 0.0002  | PWM R/L = 89/98
FWD | t = 0.41 s  | R: 0.134 turns, L: 0.187 turns  | avg dist ≈ 0.033 m  | error(turns) = 0.0526  | PWM R/L = 88/98
FWD | t = 0.81 s  | R: 0.359 turns, L: 0.417 turns  | avg dist ≈ 0.080 m  | error(turns) = 0.0581  | PWM R/L = 88/98
FWD | t = 1.22 s  | R: 0.594 turns, L: 0.656 turns  | avg dist ≈ 0.130 m  | error(turns) = 0.0625  | PWM R/L = 88/97
FWD | t = 1.62 s  | R: 0.827 turns, L: 0.889 turns  | avg dist ≈ 0.178 m  | error(turns) = 0.0619  | PWM R/L = 88/98
FWD | t = 2.03 s  | R: 1.068 turns, L: 1.130 turns  | avg dist ≈ 0.228 m  | error(turns) = 0.0616  | PWM R/L = 88/98
FWD | t = 2.43 s  | R: 1.306 turns, L: 2.304 turns  | avg dist ≈ 0.374 m  | error(turns) = 0.9979  | PWM R/L = 87/90
FWD | t = 2.83 s  | R: 1.591 turns, L: 2.339 turns  | avg dist ≈ 0.407 m  | error(turns) = 0.7479  | PWM R/L = 87/92
FWD | t = 3.24 s  | R: 1.879 turns, L: 2.380 turns  | avg dist ≈ 0.441 m  | error(turns) = 0.5010  | PWM R/L = 87/94
FWD | t = 3.64 s  | R: 2.175 turns, L: 2.448 turns  | avg dist ≈ 0.479 m  | error(turns) = 0.2731  | PWM R/L = 87/96
FWD | t = 4.04 s  | R: 2.467 turns, L: 2.604 turns  | avg dist ≈ 0.526 m  | error(turns) = 0.1367  | PWM R/L = 88/97
FWD | t = 4.45 s  | R: 2.699 turns, L: 2.797 turns  | avg dist ≈ 0.570 m  | error(turns) = 0.0980  | PWM R/L = 88/97
FWD | t = 4.85 s  | R: 2.939 turns, L: 2.996 turns  | avg dist ≈ 0.615 m  | error(turns) = 0.0568  | PWM R/L = 88/98
FWD | t = 5.25 s  | R: 3.170 turns, L: 3.230 turns  | avg dist ≈ 0.664 m  | error(turns) = 0.0606  | PWM R/L = 88/98
FWD | t = 5.65 s  | R: 3.399 turns, L: 3.467 turns  | avg dist ≈ 0.712 m  | error(turns) = 0.0671  | PWM R/L = 88/97
FWD | t = 6.06 s  | R: 3.632 turns, L: 3.691 turns  | avg dist ≈ 0.759 m  | error(turns) = 0.0595  | PWM R/L = 88/98
FWD | t = 6.46 s  | R: 3.862 turns, L: 3.923 turns  | avg dist ≈ 0.807 m  | error(turns) = 0.0614  | PWM R/L = 88/98
FWD | t = 6.87 s  | R: 4.104 turns, L: 4.166 turns  | avg dist ≈ 0.857 m  | error(turns) = 0.0620  | PWM R/L = 88/98
FWD | t = 7.27 s  | R: 4.335 turns, L: 4.408 turns  | avg dist ≈ 0.906 m  | error(turns) = 0.0732  | PWM R/L = 88/97
FWD | t = 7.67 s  | R: 4.564 turns, L: 4.625 turns  | avg dist ≈ 0.953 m  | error(turns) = 0.0615  | PWM R/L = 88/98
!! Timeout in moveForward2m, stopping.
-- FORWARD 2m END ---
Final turns  R: 4.751  L: 4.811  | avg distance ≈ 0.991 m

>>> Waiting 3 seconds before moving backward...

--- BACKWARD 2m START ---
BACK | t = 0.01 s  | R: 0.000 turns, L: 0.000 turns  | avg dist ≈ 0.000 m  | error(turns) = 0.0003  | PWM R/L = 99/90
BACK | t = 0.41 s  | R: 0.141 turns, L: 0.039 turns  | avg dist ≈ 0.019 m  | error(turns) = -0.1012  | PWM R/L = 98/89
BACK | t = 0.81 s  | R: 0.299 turns, L: 0.139 turns  | avg dist ≈ 0.045 m  | error(turns) = -0.1603  | PWM R/L = 97/89
BACK | t = 1.22 s  | R: 0.409 turns, L: 0.237 turns  | avg dist ≈ 0.067 m  | error(turns) = -0.1719  | PWM R/L = 97/89
BACK | t = 1.62 s  | R: 0.520 turns, L: 0.335 turns  | avg dist ≈ 0.089 m  | error(turns) = -0.1845  | PWM R/L = 97/89
BACK | t = 2.02 s  | R: 0.628 turns, L: 0.443 turns  | avg dist ≈ 0.111 m  | error(turns) = -0.1852  | PWM R/L = 97/89
BACK | t = 2.43 s  | R: 0.734 turns, L: 0.561 turns  | avg dist ≈ 0.134 m  | error(turns) = -0.1736  | PWM R/L = 97/89
BACK | t = 2.83 s  | R: 0.843 turns, L: 0.666 turns  | avg dist ≈ 0.156 m  | error(turns) = -0.1763  | PWM R/L = 97/89
BACK | t = 3.23 s  | R: 0.964 turns, L: 0.782 turns  | avg dist ≈ 0.181 m  | error(turns) = -0.1820  | PWM R/L = 97/89
BACK | t = 3.64 s  | R: 1.072 turns, L: 0.889 turns  | avg dist ≈ 0.203 m  | error(turns) = -0.1829  | PWM R/L = 97/89
BACK | t = 4.04 s  | R: 1.180 turns, L: 0.998 turns  | avg dist ≈ 0.226 m  | error(turns) = -0.1821  | PWM R/L = 97/89
BACK | t = 4.45 s  | R: 1.290 turns, L: 1.104 turns  | avg dist ≈ 0.248 m  | error(turns) = -0.1860  | PWM R/L = 97/89
BACK | t = 4.85 s  | R: 1.400 turns, L: 1.212 turns  | avg dist ≈ 0.271 m  | error(turns) = -0.1877  | PWM R/L = 97/88
BACK | t = 5.26 s  | R: 1.510 turns, L: 1.324 turns  | avg dist ≈ 0.294 m  | error(turns) = -0.1852  | PWM R/L = 97/89
BACK | t = 5.66 s  | R: 1.619 turns, L: 1.432 turns  | avg dist ≈ 0.316 m  | error(turns) = -0.1875  | PWM R/L = 97/88
BACK | t = 6.07 s  | R: 1.727 turns, L: 1.553 turns  | avg dist ≈ 0.340 m  | error(turns) = -0.1736  | PWM R/L = 97/89
BACK | t = 6.47 s  | R: 1.835 turns, L: 1.661 turns  | avg dist ≈ 0.362 m  | error(turns) = -0.1736  | PWM R/L = 97/89
BACK | t = 6.88 s  | R: 1.957 turns, L: 1.771 turns  | avg dist ≈ 0.386 m  | error(turns) = -0.1859  | PWM R/L = 97/89
BACK | t = 7.28 s  | R: 2.065 turns, L: 1.877 turns  | avg dist ≈ 0.409 m  | error(turns) = -0.1881  | PWM R/L = 97/88
BACK | t = 7.69 s  | R: 2.174 turns, L: 1.990 turns  | avg dist ≈ 0.432 m  | error(turns) = -0.1838  | PWM R/L = 97/89
!! Timeout in moveBackward2m, stopping.

--- BACKWARD 2m END ---
Final turns  R: 2.258  L: 2.075  | avg distance ≈ 0.449 m

>>> Cycle complete!




#include <Servo.h>
#include <math.h>    // for fabs()

/* ---------------------------------------------------------
   SERVO OBJECTS
--------------------------------------------------------- */
Servo servoRight;
Servo servoLeft;

/* ---------------------------------------------------------
   PIN ASSIGNMENTS (CHECK WITH YOUR WIRING!)
   Feedback: yellow wires from Parallax 360°
   Control:  white wires from Parallax 360°
--------------------------------------------------------- */
constexpr int pinFeedbackLeft  = 7;
constexpr int pinFeedbackRight = 8;
constexpr int pinControlLeft   = 5;
constexpr int pinControlRight  = 6;

char keyCommand;

/* ---------------------------------------------------------
   ENCODER RAW MEASUREMENTS
--------------------------------------------------------- */
unsigned long highRight = 0, highLeft = 0;
unsigned long lowRight  = 0, lowLeft  = 0;
unsigned long cycleTimeRight = 0, cycleTimeLeft = 0;
double dutyCycleRight = 0.0, dutyCycleLeft = 0.0;

/* ---------------------------------------------------------
   ANGLES AND ROTATIONS
   thetaX     = current angle (0..360)
   thetaXP    = previous angle
   totalTurnsX = accumulated wheel rotations (0.5, 1.25, ...)
--------------------------------------------------------- */
double thetaRight  = 0.0, thetaLeft  = 0.0;
double thetaRightP = 0.0, thetaLeftP = 0.0;

double totalTurnsRight = 0.0;
double totalTurnsLeft  = 0.0;

/* ---------------------------------------------------------
   WHEEL GEOMETRY & TARGET DISTANCE
   Diameter = 6.6 cm = 0.066 m
--------------------------------------------------------- */
const double wheelDiameter   = 0.066;                       // meters
const double wheelCirc       = 3.14159 * wheelDiameter;     // meters per 1 rotation
const double targetDistance  = 2.0;                         // meters
const double targetRotations = targetDistance / wheelCirc;  // turns needed for ~2m

/* ---------------------------------------------------------
   SERVO MAPPING
   We control a "signed speed" S:
     S > 0  => forward
     S < 0  => backward
     S = 0  => stop
   and convert S -> PWM for each wheel using a linear map
   fitted to your earlier calibration.
--------------------------------------------------------- */
const int    PWM_NEUTRAL  = 94;   // stop position
const double K_RIGHT_PWM  = 5.0;  // how much 1.0 "speed" changes right PWM
const double K_LEFT_PWM   = 4.0;  // how much 1.0 "speed" changes left PWM

// Base speeds (in "S" units) for forward & backward
const double S_BASE_FWD   = 1.0;   // ~forward speed (tune if too fast/slow)
const double S_BASE_BACK  = 1.0;  // ~backward speed

// P-controller gain to equalize wheel speeds (in turns)
const double Kp_turns     = 2.0;   // if left is ahead in turns, slow left / speed right

/* ---------------------------------------------------------
   HELPER FUNCTION DECLARATIONS
--------------------------------------------------------- */
void calculateThetaRight();
void calculateThetaLeft();
void stopRobot();
void updateEncodersAndAccumulate();
void moveForward2m();
void moveBackward2m();
double getAverageDistance();

/* ---------------------------------------------------------
   SETUP
--------------------------------------------------------- */
void setup() {
  Serial.begin(9600);
  pinMode(pinFeedbackRight, INPUT);
  pinMode(pinFeedbackLeft,  INPUT);

  Serial.println("===== ROBOT READY =====");
  Serial.print("Wheel diameter: ");
  Serial.print(wheelDiameter * 100.0, 1);
  Serial.println(" cm");

  Serial.print("Wheel circumference: ");
  Serial.print(wheelCirc, 4);
  Serial.println(" m");

  Serial.print("Target rotations for 2m: ");
  Serial.println(targetRotations, 3);

  Serial.println("\nCommands:");
  Serial.println("  'f' - Move forward 2m, wait 3s, then backward 2m");
  Serial.println("  's' - Emergency stop");
  Serial.println("  't' - Test LEFT motor only (3s)");
  Serial.println("=======================\n");
}

/* ---------------------------------------------------------
   MAIN LOOP
--------------------------------------------------------- */
void loop() {
  if (Serial.available() > 0) {
    keyCommand = Serial.read();

    switch (keyCommand) {

      case 'f':
        Serial.println("\n>>> Starting forward-backward cycle...");
        moveForward2m();
        Serial.println(">>> Waiting 3 seconds before moving backward...");
        delay(3000);  // *** 3 second pause before going backward ***
        moveBackward2m();
        Serial.println(">>> Cycle complete!\n");
        break;

      case 's':
        Serial.println("\n>>> Emergency stop!");
        stopRobot();
        break;

      case 't':  // test left motor only
        Serial.println("\n>>> Testing LEFT motor only (3s)...");
        servoLeft.attach(pinControlLeft);
        // S = +1.0 forward on left: PWM = 94 + 4*1.0 = 98
        servoLeft.write(PWM_NEUTRAL + (int)round(K_LEFT_PWM * S_BASE_FWD));
        delay(3000);
        servoLeft.write(PWM_NEUTRAL);
        delay(200);
        servoLeft.detach();
        Serial.println(">>> Left motor test complete\n");
        break;

      default:
        // ignore other keys
        break;
    }
  }
}

/* ---------------------------------------------------------
   BASIC STOP
--------------------------------------------------------- */
void stopRobot() {
  servoRight.attach(pinControlRight);
  servoLeft.attach(pinControlLeft);

  servoRight.write(PWM_NEUTRAL);
  servoLeft.write(PWM_NEUTRAL);

  delay(100);    // let servos receive stop PWM

  servoRight.detach();
  servoLeft.detach();
}

/* ---------------------------------------------------------
   ENCODER UPDATE + ACCUMULATION (IN TURNS)
--------------------------------------------------------- */
void updateEncodersAndAccumulate() {
  // store previous angles
  thetaRightP = thetaRight;
  thetaLeftP  = thetaLeft;

  // read new angles from encoders
  calculateThetaRight();
  calculateThetaLeft();

  // compute angle change
  double dR = thetaRight - thetaRightP;
  double dL = thetaLeft  - thetaLeftP;

  // handle wrap-around at 0/360 so we get the shortest step
  if (dR > 180.0)  dR -= 360.0;
  if (dR < -180.0) dR += 360.0;

  if (dL > 180.0)  dL -= 360.0;
  if (dL < -180.0) dL += 360.0;

  // accumulate absolute rotation in TURNS (deg / 360)
  totalTurnsRight += fabs(dR) / 360.0;
  totalTurnsLeft  += fabs(dL) / 360.0;
}

/* ---------------------------------------------------------
   GET AVERAGE DISTANCE (m) FROM TURNS
--------------------------------------------------------- */
double getAverageDistance() {
  double avgTurns = 0.5 * (totalTurnsRight + totalTurnsLeft);
  return avgTurns * wheelCirc;   // meters
}

/* ---------------------------------------------------------
   MOVE FORWARD ~2 METERS (WITH P-CONTROL FOR EQUAL SPEED)
--------------------------------------------------------- */
void moveForward2m() {
  Serial.println("\n--- FORWARD 2m START ---");

  totalTurnsRight = 0.0;
  totalTurnsLeft  = 0.0;

  // init previous angles so first diff is small
  calculateThetaRight();
  calculateThetaLeft();
  thetaRightP = thetaRight;
  thetaLeftP  = thetaLeft;

  servoRight.attach(pinControlRight);
  servoLeft.attach(pinControlLeft);

  unsigned long startTime = millis();

  while (totalTurnsRight < targetRotations &&
         totalTurnsLeft  < targetRotations) {

    // --- SAFETY 1: time-out in case encoders fail ---
    if (millis() - startTime > 20000) {   // 8 seconds timeout
      Serial.println("!! Timeout in moveForward2m, stopping.");
      break;
    }

    // --- SAFETY 2: allow 's' to stop immediately ---
    if (Serial.available() > 0) {
      char c = Serial.read();
      if (c == 's') {
        Serial.println("!! Stop command (s) received in moveForward2m.");
        stopRobot();
        return;
      }
    }

    // --- UPDATE ENCODERS ---
    updateEncodersAndAccumulate();

    // --- P-CONTROL TO EQUALIZE TURNS (SPEEDS) ---
    // errorTurns > 0 => left wheel has more turns (ahead)
    double errorTurns = totalTurnsLeft - totalTurnsRight;
    double correction = Kp_turns * errorTurns;

    // base forward speed
    double S_right = S_BASE_FWD + correction;
    double S_left  = S_BASE_FWD - correction;

    // limit S so PWM stays in safe range
    S_right = constrain(S_right, -1.5, 1.5);
    S_left  = constrain(S_left,  -1.5, 1.5);

    // map S to PWM for each wheel
    int pwmRight = (int)round(PWM_NEUTRAL - K_RIGHT_PWM * S_right);
    int pwmLeft  = (int)round(PWM_NEUTRAL + K_LEFT_PWM  * S_left);

    // clamp PWM to valid servo range
    pwmRight = constrain(pwmRight, 60, 130);
    pwmLeft  = constrain(pwmLeft,  60, 130);

    // send commands
    servoRight.write(pwmRight);
    servoLeft.write(pwmLeft);

    // --- DEBUG OUTPUT every 400ms ---
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 400) {
      double dist = getAverageDistance();
      Serial.print("FWD | t = ");
      Serial.print((millis() - startTime) / 1000.0, 2);
      Serial.print(" s  | R: ");
      Serial.print(totalTurnsRight, 3);
      Serial.print(" turns, L: ");
      Serial.print(totalTurnsLeft, 3);
      Serial.print(" turns  | avg dist ≈ ");
      Serial.print(dist, 3);
      Serial.print(" m  | error(turns) = ");
      Serial.print(errorTurns, 4);
      Serial.print("  | PWM R/L = ");
      Serial.print(pwmRight);
      Serial.print("/");
      Serial.println(pwmLeft);
      lastPrint = millis();
    }
  }

  double finalDist = getAverageDistance();
  Serial.println("\n--- FORWARD 2m END ---");
  Serial.print("Final turns  R: ");
  Serial.print(totalTurnsRight, 3);
  Serial.print("  L: ");
  Serial.print(totalTurnsLeft, 3);
  Serial.print("  | avg distance ≈ ");
  Serial.print(finalDist, 3);
  Serial.println(" m\n");

  stopRobot();
}

/* ---------------------------------------------------------
   MOVE BACKWARD ~2 METERS (WITH P-CONTROL FOR EQUAL SPEED)
--------------------------------------------------------- */
void moveBackward2m() {
  Serial.println("\n--- BACKWARD 2m START ---");

  totalTurnsRight = 0.0;
  totalTurnsLeft  = 0.0;

  // init previous angles
  calculateThetaRight();
  calculateThetaLeft();
  thetaRightP = thetaRight;
  thetaLeftP  = thetaLeft;

  servoRight.attach(pinControlRight);
  servoLeft.attach(pinControlLeft);

  unsigned long startTime = millis();

  while (totalTurnsRight < targetRotations &&
         totalTurnsLeft  < targetRotations) {

    // --- SAFETY 1: time-out ---
    if (millis() - startTime > 20000) {
      Serial.println("!! Timeout in moveBackward2m, stopping.");
      break;
    }

    // --- SAFETY 2: allow 's' to stop immediately ---
    if (Serial.available() > 0) {
      char c = Serial.read();
      if (c == 's') {
        Serial.println("!! Stop command (s) received in moveBackward2m.");
        stopRobot();
        return;
      }
    }

    // --- UPDATE ENCODERS ---
    updateEncodersAndAccumulate();

    // --- P-CONTROL TO EQUALIZE TURNS (SPEEDS) ---
    // Same idea as forward: errorTurns > 0 => left ahead
    double errorTurns = totalTurnsLeft - totalTurnsRight;
    double correction = Kp_turns * errorTurns;

    // base backward speed
    double S_right = S_BASE_BACK + correction;
    double S_left  = S_BASE_BACK - correction;

    // limit S
    S_right = constrain(S_right, 0.0, 1.5);
    S_left  = constrain(S_left,  0.0, 1.5);

    // map S to PWM
    int pwmRight = (int)round(PWM_NEUTRAL + K_RIGHT_PWM * S_right);
    int pwmLeft  = (int)round(PWM_NEUTRAL - K_LEFT_PWM  * S_left);

    pwmRight = constrain(pwmRight, 60, 130);
    pwmLeft  = constrain(pwmLeft,  60, 130);

    servoRight.write(pwmRight);
    servoLeft.write(pwmLeft);

    // --- DEBUG OUTPUT every 400ms ---
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 400) {
      double dist = getAverageDistance();
      Serial.print("BACK | t = ");
      Serial.print((millis() - startTime) / 1000.0, 2);
      Serial.print(" s  | R: ");
      Serial.print(totalTurnsRight, 3);
      Serial.print(" turns, L: ");
      Serial.print(totalTurnsLeft, 3);
      Serial.print(" turns  | avg dist ≈ ");
      Serial.print(dist, 3);
      Serial.print(" m  | error(turns) = ");
      Serial.print(errorTurns, 4);
      Serial.print("  | PWM R/L = ");
      Serial.print(pwmRight);
      Serial.print("/");
      Serial.println(pwmLeft);
      lastPrint = millis();
    }
  }

  double finalDist = getAverageDistance();
  Serial.println("\n--- BACKWARD 2m END ---");
  Serial.print("Final turns  R: ");
  Serial.print(totalTurnsRight, 3);
  Serial.print("  L: ");
  Serial.print(totalTurnsLeft, 3);
  Serial.print("  | avg distance ≈ ");
  Serial.print(finalDist, 3);
  Serial.println(" m\n");

  stopRobot();
}

/* ---------------------------------------------------------
   ENCODER FUNCTIONS – Parallax datasheet mapping
   Convert duty cycle → angle 0..360
--------------------------------------------------------- */
void calculateThetaRight() {
  highRight = pulseIn(pinFeedbackRight, HIGH);
  lowRight  = pulseIn(pinFeedbackRight, LOW);
  cycleTimeRight = highRight + lowRight;

  if (cycleTimeRight == 0) {
    // no valid pulse → keep previous thetaRight
    return;
  }

  dutyCycleRight = (double)(highRight * 100.0) / (double)cycleTimeRight;

  // Map 2.9%..97.1% duty to ~0..360 degrees (slightly adjusted)
  thetaRight = (360.0 - 1.0)
               - ((dutyCycleRight - 2.9) * 360.0) / (97.1 - 2.9 + 1.0);
}

void calculateThetaLeft() {
  highLeft = pulseIn(pinFeedbackLeft, HIGH);
  lowLeft  = pulseIn(pinFeedbackLeft, LOW);
  cycleTimeLeft = highLeft + lowLeft;

  if (cycleTimeLeft == 0) {
    // no valid pulse → keep previous thetaLeft
    return;
  }

  dutyCycleLeft = (double)(highLeft * 100.0) / (double)cycleTimeLeft;

  thetaLeft = (360.0 - 1.0)
              - ((dutyCycleLeft - 2.9) * 360.0) / (97.1 - 2.9 + 1.0);
}
